<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>XSL Library Template Reference</title>
      <link rel="stylesheet" href="../css/reference.css" type="text/css">
      <meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div class="book" lang="en">
         <div class="titlepage">
            <div>
               <div>
                  <h1 class="title"><a name="d0e1"></a>XSL Library Template Reference
                  </h1>
               </div>
               <div>
                  <h3 class="corpauthor">The DocBook Project</h3>
               </div>
               <div>
                  <p class="releaseinfo">$Id: lib.xweb 6369 2006-10-19 08:40:35Z xmldoc $
                     
                  </p>
               </div>
               <div>
                  <p class="copyright"><a href="../copyright.html">Copyright</a> &copy; 19992000200120022005 by Norman Walsh. <a href="../warranty.html">No Warranty</a>.
                  </p>
               </div>
            </div>
            <hr>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="preface"><a href="#intro">Introduction</a></span></dt>
               <dt><span class="reference"><a href="#generallibrary">I. General Library Templates</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="refentrytitle"><a href="#dot.count">dot.count</a></span><span class="refpurpose"> &#8212; Returns the number of &#8220;<span class="quote">.</span>&#8221; characters in a string</span></dt>
                     <dt><span class="refentrytitle"><a href="#copy-string">copy-string</a></span><span class="refpurpose"> &#8212; Returns &#8220;<span class="quote">count</span>&#8221; copies of a string</span></dt>
                     <dt><span class="refentrytitle"><a href="#string.subst">string.subst</a></span><span class="refpurpose"> &#8212; Substitute one text string for another in a string</span></dt>
                     <dt><span class="refentrytitle"><a href="#xpointer.idref">xpointer.idref</a></span><span class="refpurpose"> &#8212; Extract IDREF from an XPointer</span></dt>
                     <dt><span class="refentrytitle"><a href="#length-magnitude">length-magnitude</a></span><span class="refpurpose"> &#8212; Return the unqualified dimension from a length specification</span></dt>
                     <dt><span class="refentrytitle"><a href="#length-units">length-units</a></span><span class="refpurpose"> &#8212; Return the units from a length specification</span></dt>
                     <dt><span class="refentrytitle"><a href="#length-spec">length-spec</a></span><span class="refpurpose"> &#8212; Return a fully qualified length specification</span></dt>
                     <dt><span class="refentrytitle"><a href="#length-in-points">length-in-points</a></span><span class="refpurpose"> &#8212; Returns the size, in points, of a specified length</span></dt>
                     <dt><span class="refentrytitle"><a href="#pi-attribute">pi-attribute</a></span><span class="refpurpose"> &#8212; Extract a pseudo-attribute from a PI</span></dt>
                     <dt><span class="refentrytitle"><a href="#lookup.key">lookup.key</a></span><span class="refpurpose"> &#8212; Retrieve the value associated with a particular key in a table</span></dt>
                     <dt><span class="refentrytitle"><a href="#xpath.location">xpath.location</a></span><span class="refpurpose"> &#8212; Calculate the XPath child-sequence to the current node</span></dt>
                     <dt><span class="refentrytitle"><a href="#comment-escape-string">comment-escape-string</a></span><span class="refpurpose"> &#8212; Prepare a string for inclusion in an XML comment</span></dt>
                     <dt><span class="refentrytitle"><a href="#comment-escape-string.recursive">comment-escape-string.recursive</a></span><span class="refpurpose"> &#8212; Internal function used by comment-escape-string</span></dt>
                     <dt><span class="refentrytitle"><a href="#prepend-pad">prepend-pad</a></span><span class="refpurpose"> &#8212; Right-pad a string out to a certain length</span></dt>
                     <dt><span class="refentrytitle"><a href="#trim.text">trim.text</a></span><span class="refpurpose"> &#8212; Trim leading and trailing whitespace from a text node</span></dt>
                     <dt><span class="refentrytitle"><a href="#str.tokenize.keep.delimiters">str.tokenize.keep.delimiters</a></span><span class="refpurpose"> &#8212; Tokenize a string while preserving any delimiters</span></dt>
                     <dt><span class="refentrytitle"><a href="#apply-string-subst-map">apply-string-subst-map</a></span><span class="refpurpose"> &#8212; Apply a string-substitution map</span></dt>
                     <dt><span class="refentrytitle"><a href="#apply-character-map">apply-character-map</a></span><span class="refpurpose"> &#8212; Apply an XSLT character map</span></dt>
                     <dt><span class="refentrytitle"><a href="#read-character-map">read-character-map</a></span><span class="refpurpose"> &#8212; Read in all or part of an XSLT character map</span></dt>
                  </dl>
               </dd>
               <dt><span class="reference"><a href="#relativeuri">II. Relative URI Functions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="refentrytitle"><a href="#count.uri.path.depth">count.uri.path.depth</a></span><span class="refpurpose"> &#8212; Count the number of path components in a relative URI</span></dt>
                     <dt><span class="refentrytitle"><a href="#trim.common.uri.paths">trim.common.uri.paths</a></span><span class="refpurpose"> &#8212; Trim common leading path components from a relative URI</span></dt>
                  </dl>
               </dd>
               <dt><span class="appendix"><a href="#stylesheet">A. The Stylesheet</a></span></dt>
            </dl>
         </div>
         <div class="preface" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="intro"></a>Introduction
                     </h2>
                  </div>
               </div>
            </div>
            <p>This is technical reference documentation for the DocBook XSL
               Stylesheets; it documents (some of) the parameters, templates, and
               other elements of the stylesheets.
            </p>
            <p>This is not intended to be &#8220;<span class="quote">user</span>&#8221; documentation.
               It is provided for developers writing customization layers for the
               stylesheets, and for anyone who's interested in &#8220;<span class="quote">how it
                  works</span>&#8221;.
            </p>
            <p>Although I am trying to be thorough, this documentation is known
               to be incomplete. Don't forget to read the source, too :-)
            </p>
         </div>
         <div class="reference" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h1 class="title"><a name="generallibrary"></a>General Library Templates
                     </h1>
                  </div>
               </div>
               <hr>
            </div>
            <div class="toc">
               <p><b>Table of Contents</b></p>
               <dl>
                  <dt><span class="refentrytitle"><a href="#dot.count">dot.count</a></span><span class="refpurpose"> &#8212; Returns the number of &#8220;<span class="quote">.</span>&#8221; characters in a string</span></dt>
                  <dt><span class="refentrytitle"><a href="#copy-string">copy-string</a></span><span class="refpurpose"> &#8212; Returns &#8220;<span class="quote">count</span>&#8221; copies of a string</span></dt>
                  <dt><span class="refentrytitle"><a href="#string.subst">string.subst</a></span><span class="refpurpose"> &#8212; Substitute one text string for another in a string</span></dt>
                  <dt><span class="refentrytitle"><a href="#xpointer.idref">xpointer.idref</a></span><span class="refpurpose"> &#8212; Extract IDREF from an XPointer</span></dt>
                  <dt><span class="refentrytitle"><a href="#length-magnitude">length-magnitude</a></span><span class="refpurpose"> &#8212; Return the unqualified dimension from a length specification</span></dt>
                  <dt><span class="refentrytitle"><a href="#length-units">length-units</a></span><span class="refpurpose"> &#8212; Return the units from a length specification</span></dt>
                  <dt><span class="refentrytitle"><a href="#length-spec">length-spec</a></span><span class="refpurpose"> &#8212; Return a fully qualified length specification</span></dt>
                  <dt><span class="refentrytitle"><a href="#length-in-points">length-in-points</a></span><span class="refpurpose"> &#8212; Returns the size, in points, of a specified length</span></dt>
                  <dt><span class="refentrytitle"><a href="#pi-attribute">pi-attribute</a></span><span class="refpurpose"> &#8212; Extract a pseudo-attribute from a PI</span></dt>
                  <dt><span class="refentrytitle"><a href="#lookup.key">lookup.key</a></span><span class="refpurpose"> &#8212; Retrieve the value associated with a particular key in a table</span></dt>
                  <dt><span class="refentrytitle"><a href="#xpath.location">xpath.location</a></span><span class="refpurpose"> &#8212; Calculate the XPath child-sequence to the current node</span></dt>
                  <dt><span class="refentrytitle"><a href="#comment-escape-string">comment-escape-string</a></span><span class="refpurpose"> &#8212; Prepare a string for inclusion in an XML comment</span></dt>
                  <dt><span class="refentrytitle"><a href="#comment-escape-string.recursive">comment-escape-string.recursive</a></span><span class="refpurpose"> &#8212; Internal function used by comment-escape-string</span></dt>
                  <dt><span class="refentrytitle"><a href="#prepend-pad">prepend-pad</a></span><span class="refpurpose"> &#8212; Right-pad a string out to a certain length</span></dt>
                  <dt><span class="refentrytitle"><a href="#trim.text">trim.text</a></span><span class="refpurpose"> &#8212; Trim leading and trailing whitespace from a text node</span></dt>
                  <dt><span class="refentrytitle"><a href="#str.tokenize.keep.delimiters">str.tokenize.keep.delimiters</a></span><span class="refpurpose"> &#8212; Tokenize a string while preserving any delimiters</span></dt>
                  <dt><span class="refentrytitle"><a href="#apply-string-subst-map">apply-string-subst-map</a></span><span class="refpurpose"> &#8212; Apply a string-substitution map</span></dt>
                  <dt><span class="refentrytitle"><a href="#apply-character-map">apply-character-map</a></span><span class="refpurpose"> &#8212; Apply an XSLT character map</span></dt>
                  <dt><span class="refentrytitle"><a href="#read-character-map">read-character-map</a></span><span class="refpurpose"> &#8212; Read in all or part of an XSLT character map</span></dt>
               </dl>
            </div>
            <div class="refentry" lang="en"><a name="dot.count"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>dot.count &#8212; Returns the number of &#8220;<span class="quote">.</span>&#8221; characters in a string
                  </p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e49"></a><h2>Description</h2><pre class="programlisting"><a name="dot.count.frag"></a><pre class="programlisting">
&lt;xsl:template name="dot.count"&gt;
  &lt;!-- Returns the number of "." characters in a string --&gt;
  &lt;xsl:param name="string"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="count" select="0"&gt;&lt;/xsl:param&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($string, '.')"&gt;
      &lt;xsl:call-template name="dot.count"&gt;
        &lt;xsl:with-param name="string" select="substring-after($string, '.')"&gt;&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="count" select="$count+1"&gt;&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="$count"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="copy-string"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>copy-string &#8212; Returns &#8220;<span class="quote">count</span>&#8221; copies of a string
                  </p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e64"></a><h2>Description</h2><pre class="programlisting"><a name="copy-string.frag"></a><pre class="programlisting">
&lt;xsl:template name="copy-string"&gt;
  &lt;!-- returns 'count' copies of 'string' --&gt;
  &lt;xsl:param name="string"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="count" select="0"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="result"&gt;&lt;/xsl:param&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="$count&gt;0"&gt;
      &lt;xsl:call-template name="copy-string"&gt;
        &lt;xsl:with-param name="string" select="$string"&gt;&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="count" select="$count - 1"&gt;&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="result"&gt;
          &lt;xsl:value-of select="$result"&gt;&lt;/xsl:value-of&gt;
          &lt;xsl:value-of select="$string"&gt;&lt;/xsl:value-of&gt;
        &lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="$result"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="string.subst"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>string.subst &#8212; Substitute one text string for another in a string</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e76"></a><h2>Description</h2>
                  <p>The <code class="function">string.subst</code> template replaces all
                     occurances of <em class="parameter"><code>target</code></em> in <em class="parameter"><code>string</code></em>
                     with <em class="parameter"><code>replacement</code></em> and returns the result.
                     
                  </p><pre class="programlisting"><a name="string.subst.frag"></a><pre class="programlisting">
&lt;xsl:template name="string.subst"&gt;
  &lt;xsl:param name="string"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="target"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="replacement"&gt;&lt;/xsl:param&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($string, $target)"&gt;
      &lt;xsl:variable name="rest"&gt;
        &lt;xsl:call-template name="string.subst"&gt;
          &lt;xsl:with-param name="string" select="substring-after($string, $target)"&gt;&lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="target" select="$target"&gt;&lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="replacement" select="$replacement"&gt;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:variable&gt;
      &lt;xsl:value-of select="concat(substring-before($string, $target),                                    $replacement,                                    $rest)"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="$string"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="xpointer.idref"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>xpointer.idref &#8212; Extract IDREF from an XPointer</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e102"></a><h2>Description</h2>
                  <p>The <code class="function">xpointer.idref</code> template returns the
                     ID portion of an XPointer which is a pointer to an ID within the current
                     document, or the empty string if it is not.
                  </p>
                  <p>In other words, <code class="function">xpointer.idref</code> returns
                     &#8220;<span class="quote">foo</span>&#8221; when passed either <code class="literal">#foo</code>
                     or <code class="literal">#xpointer(id('foo'))</code>, otherwise it returns
                     the empty string.
                  </p><pre class="programlisting"><a name="xpointer.idref.frag"></a><pre class="programlisting">
&lt;xsl:template name="xpointer.idref"&gt;
  &lt;xsl:param name="xpointer"&gt;http://...&lt;/xsl:param&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="starts-with($xpointer, '#xpointer(id(')"&gt;
      &lt;xsl:variable name="rest" select="substring-after($xpointer, '#xpointer(id(')"&gt;&lt;/xsl:variable&gt;
      &lt;xsl:variable name="quote" select="substring($rest, 1, 1)"&gt;&lt;/xsl:variable&gt;
      &lt;xsl:value-of select="substring-before(substring-after($xpointer, $quote), $quote)"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="starts-with($xpointer, '#')"&gt;
      &lt;xsl:value-of select="substring-after($xpointer, '#')"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;!-- otherwise it's a pointer to some other document --&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="length-magnitude"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>length-magnitude &#8212; Return the unqualified dimension from a length specification</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e133"></a><h2>Description</h2>
                  <p>The <code class="function">length-magnitude</code> template returns the
                     unqualified length ("20" for "20pt") from a dimension.
                     
                  </p><pre class="programlisting"><a name="length-magnitude.frag"></a><pre class="programlisting">
&lt;xsl:template name="length-magnitude"&gt;
  &lt;xsl:param name="length" select="'0pt'"&gt;&lt;/xsl:param&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="string-length($length) = 0"&gt;&lt;/xsl:when&gt;
    &lt;xsl:when test="substring($length,1,1) = '0'                     or substring($length,1,1) = '1'                     or substring($length,1,1) = '2'                     or substring($length,1,1) = '3'                     or substring($length,1,1) = '4'                     or substring($length,1,1) = '5'                     or substring($length,1,1) = '6'                     or substring($length,1,1) = '7'                     or substring($length,1,1) = '8'                     or substring($length,1,1) = '9'                     or substring($length,1,1) = '.'"&gt;
      &lt;xsl:value-of select="substring($length,1,1)"&gt;&lt;/xsl:value-of&gt;
      &lt;xsl:call-template name="length-magnitude"&gt;
        &lt;xsl:with-param name="length" select="substring($length,2)"&gt;&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:when&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="length-units"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>length-units &#8212; Return the units from a length specification</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e150"></a><h2>Description</h2>
                  <p>The <code class="function">length-units</code> template returns the
                     units ("pt" for "20pt") from a length. If no units are supplied on the
                     length, the <em class="parameter"><code>defauilt.units</code></em> are returned.
                  </p><pre class="programlisting"><a name="length-units.frag"></a><pre class="programlisting">
&lt;xsl:template name="length-units"&gt;
  &lt;xsl:param name="length" select="'0pt'"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="default.units" select="'px'"&gt;&lt;/xsl:param&gt;
  &lt;xsl:variable name="magnitude"&gt;
    &lt;xsl:call-template name="length-magnitude"&gt;
      &lt;xsl:with-param name="length" select="$length"&gt;&lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:variable name="units"&gt;
    &lt;xsl:value-of select="substring($length, string-length($magnitude)+1)"&gt;&lt;/xsl:value-of&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="$units = ''"&gt;
      &lt;xsl:value-of select="$default.units"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="$units"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="length-spec"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>length-spec &#8212; Return a fully qualified length specification</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e170"></a><h2>Description</h2>
                  <p>The <code class="function">length-spec</code> template returns the
                     qualified length from a dimension. If an unqualified length is given,
                     the <em class="parameter"><code>default.units</code></em> will be added to it.
                     
                  </p><pre class="programlisting"><a name="length-spec.frag"></a><pre class="programlisting">
&lt;xsl:template name="length-spec"&gt;
  &lt;xsl:param name="length" select="'0pt'"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="default.units" select="'px'"&gt;&lt;/xsl:param&gt;

  &lt;xsl:variable name="magnitude"&gt;
    &lt;xsl:call-template name="length-magnitude"&gt;
      &lt;xsl:with-param name="length" select="$length"&gt;&lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:variable name="units"&gt;
    &lt;xsl:value-of select="substring($length, string-length($magnitude)+1)"&gt;&lt;/xsl:value-of&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:value-of select="$magnitude"&gt;&lt;/xsl:value-of&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="$units='cm'                     or $units='mm'                     or $units='in'                     or $units='pt'                     or $units='pc'                     or $units='px'                     or $units='em'"&gt;
      &lt;xsl:value-of select="$units"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="$units = ''"&gt;
      &lt;xsl:value-of select="$default.units"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:message&gt;
        &lt;xsl:text&gt;Unrecognized unit of measure: &lt;/xsl:text&gt;
        &lt;xsl:value-of select="$units"&gt;&lt;/xsl:value-of&gt;
        &lt;xsl:text&gt;.&lt;/xsl:text&gt;
      &lt;/xsl:message&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="length-in-points"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>length-in-points &#8212; Returns the size, in points, of a specified length</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e190"></a><h2>Description</h2>
                  <p>The <code class="function">length-in-points</code> template converts a length
                     specification to points and returns that value as an unqualified
                     number.
                     
                  </p>
                  <div class="caution">
                     <table border="0" summary="Caution">
                        <tr>
                           <td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
                           <th align="left"></th>
                        </tr>
                        <tr>
                           <td align="left" valign="top">
                              <p>There is no way for the template to infer the size of an
                                 <code class="literal">em</code>. It relies on the default <em class="parameter"><code>em.size</code></em>
                                 which is initially <code class="literal">10</code> (for 10pt).
                              </p>
                              <p>Similarly, converting pixels to points relies on the
                                 <em class="parameter"><code>pixels.per.inch</code></em> parameter which is initially
                                 <code class="literal">90</code>.
                                 
                              </p>
                           </td>
                        </tr>
                     </table>
                  </div><pre class="programlisting"><a name="length-in-points.frag"></a><pre class="programlisting">
&lt;xsl:template name="length-in-points"&gt;
  &lt;xsl:param name="length" select="'0pt'"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="em.size" select="10"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="pixels.per.inch" select="90"&gt;&lt;/xsl:param&gt;

  &lt;xsl:variable name="magnitude"&gt;
    &lt;xsl:call-template name="length-magnitude"&gt;
      &lt;xsl:with-param name="length" select="$length"&gt;&lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:variable name="units"&gt;
    &lt;xsl:value-of select="substring($length, string-length($magnitude)+1)"&gt;&lt;/xsl:value-of&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="$units = 'pt'"&gt;
      &lt;xsl:value-of select="$magnitude"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="$units = 'cm'"&gt;
      &lt;xsl:value-of select="$magnitude div 2.54 * 72.0"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="$units = 'mm'"&gt;
      &lt;xsl:value-of select="$magnitude div 25.4 * 72.0"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="$units = 'in'"&gt;
      &lt;xsl:value-of select="$magnitude * 72.0"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="$units = 'pc'"&gt;
      &lt;xsl:value-of select="$magnitude * 12.0"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="$units = 'px'"&gt;
      &lt;xsl:value-of select="$magnitude div $pixels.per.inch * 72.0"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="$units = 'em'"&gt;
      &lt;xsl:value-of select="$magnitude * $em.size"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:message&gt;
        &lt;xsl:text&gt;Unrecognized unit of measure: &lt;/xsl:text&gt;
        &lt;xsl:value-of select="$units"&gt;&lt;/xsl:value-of&gt;
        &lt;xsl:text&gt;.&lt;/xsl:text&gt;
      &lt;/xsl:message&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="pi-attribute"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>pi-attribute &#8212; Extract a pseudo-attribute from a PI</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e227"></a><h2>Description</h2>
                  <p>The <code class="function">pi-attribute</code> template extracts a pseudo-attribute
                     from a processing instruction. For example, given the PI
                     &#8220;<span class="quote"><code class="literal">&lt;?foo bar="1" baz='red'?&gt;</code></span>&#8221;,
                  </p><pre class="programlisting">&lt;xsl:call-template name="pi-attribute"&gt;
  &lt;xsl:with-param name="pis" select="processing-instruction('foo')"/&gt;
  &lt;xsl:with-param name="attribute" select="'baz'"/&gt;
&lt;/xsl:call-template&gt;</pre><p>will return &#8220;<span class="quote">red</span>&#8221;. This template returns the first matching
                     attribute that it finds. Presented with processing instructions that
                     contain badly formed pseudo-attributes (missing or unbalanced quotes,
                     for example), the template may silently return erroneous results.
                  </p><pre class="programlisting"><a name="pi-attribute.frag"></a><pre class="programlisting">
&lt;xsl:template name="pi-attribute"&gt;
  &lt;xsl:param name="pis" select="processing-instruction('BOGUS_PI')"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="attribute"&gt;filename&lt;/xsl:param&gt;
  &lt;xsl:param name="count"&gt;1&lt;/xsl:param&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="$count&gt;count($pis)"&gt;
      &lt;!-- not found --&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:variable name="pi"&gt;
        &lt;xsl:value-of select="$pis[$count]"&gt;&lt;/xsl:value-of&gt;
      &lt;/xsl:variable&gt;
      &lt;xsl:variable name="pivalue"&gt;
        &lt;xsl:value-of select="concat(' ', normalize-space($pi))"&gt;&lt;/xsl:value-of&gt;
      &lt;/xsl:variable&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($pivalue,concat(' ', $attribute, '='))"&gt;
          &lt;xsl:variable name="rest" select="substring-after($pivalue,concat(' ', $attribute,'='))"&gt;&lt;/xsl:variable&gt;
          &lt;xsl:variable name="quote" select="substring($rest,1,1)"&gt;&lt;/xsl:variable&gt;
          &lt;xsl:value-of select="substring-before(substring($rest,2),$quote)"&gt;&lt;/xsl:value-of&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:call-template name="pi-attribute"&gt;
            &lt;xsl:with-param name="pis" select="$pis"&gt;&lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="attribute" select="$attribute"&gt;&lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="count" select="$count + 1"&gt;&lt;/xsl:with-param&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="lookup.key"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>lookup.key &#8212; Retrieve the value associated with a particular key in a table</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e255"></a><h2>Description</h2>
                  <p>Given a table of space-delimited key/value pairs,
                     the <code class="function">lookup.key</code> template extracts the value associated
                     with a particular key.
                  </p><pre class="programlisting"><a name="lookup.key.frag"></a><pre class="programlisting">
&lt;xsl:template name="lookup.key"&gt;
  &lt;xsl:param name="key" select="''"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="table" select="''"&gt;&lt;/xsl:param&gt;

  &lt;xsl:if test="contains($table, ' ')"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="substring-before($table, ' ') = $key"&gt;
        &lt;xsl:variable name="rest" select="substring-after($table, ' ')"&gt;&lt;/xsl:variable&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test="contains($rest, ' ')"&gt;
            &lt;xsl:value-of select="substring-before($rest, ' ')"&gt;&lt;/xsl:value-of&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:value-of select="$rest"&gt;&lt;/xsl:value-of&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:call-template name="lookup.key"&gt;
          &lt;xsl:with-param name="key" select="$key"&gt;&lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="table" select="substring-after(substring-after($table,' '), ' ')"&gt;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="xpath.location"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>xpath.location &#8212; Calculate the XPath child-sequence to the current node</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e272"></a><h2>Description</h2>
                  <p>The <code class="function">xpath.location</code> template calculates the
                     absolute path from the root of the tree to the current element node.
                     
                  </p><pre class="programlisting"><a name="xpath.location.frag"></a><pre class="programlisting">
&lt;xsl:template name="xpath.location"&gt;
  &lt;xsl:param name="node" select="."&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="path" select="''"&gt;&lt;/xsl:param&gt;

  &lt;xsl:variable name="next.path"&gt;
    &lt;xsl:value-of select="local-name($node)"&gt;&lt;/xsl:value-of&gt;
    &lt;xsl:if test="$path != ''"&gt;/&lt;/xsl:if&gt;
    &lt;xsl:value-of select="$path"&gt;&lt;/xsl:value-of&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="$node/parent::*"&gt;
      &lt;xsl:call-template name="xpath.location"&gt;
        &lt;xsl:with-param name="node" select="$node/parent::*"&gt;&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="path" select="$next.path"&gt;&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;/&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$next.path"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="comment-escape-string"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>comment-escape-string &#8212; Prepare a string for inclusion in an XML comment</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e289"></a><h2>Description</h2>
                  <p>The <code class="function">comment-escape-string</code> template returns a string
                     that has been transformed so that it can safely be output as an XML comment.
                     Internal occurrences of "--" will be replaced with "- -" and a leading and/or
                     trailing space will be added to the string, if necessary.
                  </p><pre class="programlisting"><a name="comment-escape-string.frag"></a><pre class="programlisting">
&lt;xsl:template name="comment-escape-string"&gt;
  &lt;xsl:param name="string" select="''"&gt;&lt;/xsl:param&gt;

  &lt;xsl:if test="starts-with($string, '-')"&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;/xsl:if&gt;

  &lt;xsl:call-template name="comment-escape-string.recursive"&gt;
    &lt;xsl:with-param name="string" select="$string"&gt;&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;

  &lt;xsl:if test="substring($string, string-length($string), 1) = '-'"&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="comment-escape-string.recursive"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>comment-escape-string.recursive &#8212; Internal function used by comment-escape-string</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e306"></a><h2>Description</h2>
                  <p>The <code class="function">comment-escape-string.recursive</code> template is used
                     by <code class="function">comment-escape-string</code>.
                  </p><pre class="programlisting"><a name="comment-escape-string.recursive.frag"></a><pre class="programlisting">
&lt;xsl:template name="comment-escape-string.recursive"&gt;
  &lt;xsl:param name="string" select="''"&gt;&lt;/xsl:param&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($string, '--')"&gt;
      &lt;xsl:value-of select="substring-before($string, '--')"&gt;&lt;/xsl:value-of&gt;
      &lt;xsl:value-of select="'- -'"&gt;&lt;/xsl:value-of&gt;
      &lt;xsl:call-template name="comment-escape-string.recursive"&gt;
        &lt;xsl:with-param name="string" select="substring-after($string, '--')"&gt;&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="$string"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="prepend-pad"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>prepend-pad &#8212; Right-pad a string out to a certain length</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e326"></a><h2>Description</h2>
                  <p>This function takes string <em class="parameter"><code>padVar</code></em> and
                     pads it out to the string-length <em class="parameter"><code>length</code></em>, using
                     string <em class="parameter"><code>padChar</code></em> (a space character by default)
                     as the padding string (note that <em class="parameter"><code>padChar</code></em> can be
                     a string; it is not limited to just being a single character).
                  </p>
                  <div class="note">
                     <table border="0" summary="Note">
                        <tr>
                           <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
                           <th align="left"></th>
                        </tr>
                        <tr>
                           <td align="left" valign="top">
                              <p>This function is a copy of Nate Austin's
                                 <code class="function">prepend-pad</code> function in the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.dpawson.co.uk/xsl/sect2/padding.html" target="_top">Padding
                                    Content</a> section of Dave Pawson's <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.dpawson.co.uk/xsl/index.html" target="_top">XSLT
                                    FAQ</a>.
                              </p>
                           </td>
                        </tr>
                     </table>
                  </div><pre class="programlisting"><a name="prepend-pad.frag"></a><pre class="programlisting">
  &lt;xsl:template name="prepend-pad"&gt;    
  &lt;!-- recursive template to right justify and prepend--&gt;
  &lt;!-- the value with whatever padChar is passed in   --&gt;
    &lt;xsl:param name="padChar" select="' '"&gt;&lt;/xsl:param&gt;
    &lt;xsl:param name="padVar"&gt;&lt;/xsl:param&gt;
    &lt;xsl:param name="length"&gt;&lt;/xsl:param&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="string-length($padVar) &lt; $length"&gt;
        &lt;xsl:call-template name="prepend-pad"&gt;
          &lt;xsl:with-param name="padChar" select="$padChar"&gt;&lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="padVar" select="concat($padChar,$padVar)"&gt;&lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="length" select="$length"&gt;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="substring($padVar,string-length($padVar) - $length + 1)"&gt;&lt;/xsl:value-of&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="trim.text"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>trim.text &#8212; Trim leading and trailing whitespace from a text node</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e364"></a><h2>Description</h2>
                  <p>Given a text node, this function trims leading and trailing
                     whitespace from it and returns the trimmed contents.
                  </p><pre class="programlisting"><a name="trim.text.frag"></a><pre class="programlisting">

  &lt;xsl:template name="trim.text"&gt;
    &lt;xsl:param name="contents" select="."&gt;&lt;/xsl:param&gt;
    &lt;xsl:variable name="contents-left-trimmed"&gt;
      &lt;xsl:call-template name="trim-left"&gt;
        &lt;xsl:with-param name="contents" select="$contents"&gt;&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:variable name="contents-trimmed"&gt;
      &lt;xsl:call-template name="trim-right"&gt;
        &lt;xsl:with-param name="contents" select="$contents-left-trimmed"&gt;&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:value-of select="$contents-trimmed"&gt;&lt;/xsl:value-of&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="trim-left"&gt;
    &lt;xsl:param name="contents"&gt;&lt;/xsl:param&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="starts-with($contents,'
') or                       starts-with($contents,'
') or                       starts-with($contents,' ') or                       starts-with($contents,'	')"&gt;
        &lt;xsl:call-template name="trim-left"&gt;
          &lt;xsl:with-param name="contents" select="substring($contents, 2)"&gt;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$contents"&gt;&lt;/xsl:value-of&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="trim-right"&gt;
    &lt;xsl:param name="contents"&gt;&lt;/xsl:param&gt;
    &lt;xsl:variable name="last-char"&gt;
      &lt;xsl:value-of select="substring($contents, string-length($contents), 1)"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="($last-char = '
') or                       ($last-char = '') or                       ($last-char = ' ') or                       ($last-char = '	')"&gt;
        &lt;xsl:call-template name="trim-right"&gt;
          &lt;xsl:with-param name="contents" select="substring($contents, 1, string-length($contents) - 1)"&gt;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$contents"&gt;&lt;/xsl:value-of&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="str.tokenize.keep.delimiters"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>str.tokenize.keep.delimiters &#8212; Tokenize a string while preserving any delimiters</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e378"></a><h2>Description</h2>
                  <p>Based on the occurrence of one or more delimiter characters,
                     this function breaks a string into a list of tokens and delimiters,
                     marking up each of the tokens with a <code class="sgmltag-element">token</code> element
                     and preserving the delimiters as text nodes between the tokens.
                  </p>
                  <div class="note">
                     <table border="0" summary="Note">
                        <tr>
                           <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
                           <th align="left"></th>
                        </tr>
                        <tr>
                           <td align="left" valign="top">
                              <p>This function is a very slightly modified version of a
                                 function from the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.exslt.org/" target="_top">EXSLT
                                    site</a>. The original is available at:
                                 
                                 
                              </p>
                              <div class="blockquote">
                                 <blockquote class="blockquote">
                                    <p><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.exslt.org/str/functions/tokenize/str.tokenize.template.xsl" target="_top">http://www.exslt.org/str/functions/tokenize/str.tokenize.template.xsl</a></p>
                                 </blockquote>
                              </div>
                              <p>
                                 
                                 The <code class="function">str.tokenize.keep.delimiters</code> function
                                 differs only in that it preserves the delimiters instead of
                                 discarding them.
                              </p>
                           </td>
                        </tr>
                     </table>
                  </div><pre class="programlisting"><a name="str.tokenize.keep.delimiters.frag"></a><pre class="programlisting">

  &lt;xsl:template name="str.tokenize.keep.delimiters"&gt;
    &lt;xsl:param name="string" select="''"&gt;&lt;/xsl:param&gt;
    &lt;xsl:param name="delimiters" select="' '"&gt;&lt;/xsl:param&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="not($string)"&gt;&lt;/xsl:when&gt;
      &lt;xsl:when test="not($delimiters)"&gt;
	&lt;xsl:call-template name="str.tokenize.keep.delimiters-characters"&gt;
	  &lt;xsl:with-param name="string" select="$string"&gt;&lt;/xsl:with-param&gt;
	&lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
	&lt;xsl:call-template name="str.tokenize.keep.delimiters-delimiters"&gt;
	  &lt;xsl:with-param name="string" select="$string"&gt;&lt;/xsl:with-param&gt;
	  &lt;xsl:with-param name="delimiters" select="$delimiters"&gt;&lt;/xsl:with-param&gt;
	&lt;/xsl:call-template&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="str.tokenize.keep.delimiters-characters"&gt;
    &lt;xsl:param name="string"&gt;&lt;/xsl:param&gt;
    &lt;xsl:if test="$string"&gt;
      &lt;token&gt;&lt;xsl:value-of select="substring($string, 1, 1)"&gt;&lt;/xsl:value-of&gt;&lt;/token&gt;
      &lt;xsl:call-template name="str.tokenize.keep.delimiters-characters"&gt;
	&lt;xsl:with-param name="string" select="substring($string, 2)"&gt;&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="str.tokenize.keep.delimiters-delimiters"&gt;
    &lt;xsl:param name="string"&gt;&lt;/xsl:param&gt;
    &lt;xsl:param name="delimiters"&gt;&lt;/xsl:param&gt;
    &lt;xsl:variable name="delimiter" select="substring($delimiters, 1, 1)"&gt;&lt;/xsl:variable&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="not($delimiter)"&gt;
	&lt;token&gt;&lt;xsl:value-of select="$string"&gt;&lt;/xsl:value-of&gt;&lt;/token&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="contains($string, $delimiter)"&gt;
	&lt;xsl:if test="not(starts-with($string, $delimiter))"&gt;
	  &lt;xsl:call-template name="str.tokenize.keep.delimiters-delimiters"&gt;
	    &lt;xsl:with-param name="string" select="substring-before($string, $delimiter)"&gt;&lt;/xsl:with-param&gt;
	    &lt;xsl:with-param name="delimiters" select="substring($delimiters, 2)"&gt;&lt;/xsl:with-param&gt;
	  &lt;/xsl:call-template&gt;
	&lt;/xsl:if&gt;
	&lt;!-- output each delimiter --&gt;
	&lt;xsl:value-of select="$delimiter"&gt;&lt;/xsl:value-of&gt;
	&lt;xsl:call-template name="str.tokenize.keep.delimiters-delimiters"&gt;
	  &lt;xsl:with-param name="string" select="substring-after($string, $delimiter)"&gt;&lt;/xsl:with-param&gt;
	  &lt;xsl:with-param name="delimiters" select="$delimiters"&gt;&lt;/xsl:with-param&gt;
	&lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
	&lt;xsl:call-template name="str.tokenize.keep.delimiters-delimiters"&gt;
	  &lt;xsl:with-param name="string" select="$string"&gt;&lt;/xsl:with-param&gt;
	  &lt;xsl:with-param name="delimiters" select="substring($delimiters, 2)"&gt;&lt;/xsl:with-param&gt;
	&lt;/xsl:call-template&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="apply-string-subst-map"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>apply-string-subst-map &#8212; Apply a string-substitution map</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e408"></a><h2>Description</h2>
                  <p>This function applies a "string substitution" map. Use it when
                     you want to do multiple string substitutions on the same target
                     content. It reads in two things: <em class="parameter"><code>content</code></em>, the
                     content on which to perform the substitution, and
                     <em class="parameter"><code>map.contents</code></em>, a node set of
                     elements (the names of the elements don't matter), with each element
                     having the following attributes:
                     
                  </p>
                  <div class="itemizedlist">
                     <ul type="disc">
                        <li><code class="sgmltag-attribute">oldstring</code>, a string to
                           be replaced
                        </li>
                        <li><code class="sgmltag-attribute">newstring</code>, a string with
                           which to replace <code class="sgmltag-attribute">oldstring</code></li>
                     </ul>
                  </div>
                  <p>
                     The function uses <em class="parameter"><code>map.contents</code></em> to
                     do substitution on <em class="parameter"><code>content</code></em>, and then
                     returns the modified contents.
                  </p>
                  <div class="note">
                     <table border="0" summary="Note">
                        <tr>
                           <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
                           <th align="left"></th>
                        </tr>
                        <tr>
                           <td align="left" valign="top">
                              <p>This function is a very slightly modified version of Jeni
                                 Tennison's <code class="function">replace_strings</code> function in the
                                 <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.dpawson.co.uk/xsl/sect2/StringReplace.html#d9351e13" target="_top">multiple string replacements</a> section of Dave Pawson's
                                 <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.dpawson.co.uk/xsl/index.html" target="_top">XSLT
                                    FAQ</a>.
                              </p>
                              <p>The <code class="function">apply-string-subst-map</code> function is
                                 essentially the same function as the
                                 <code class="function">apply-character-map</code> function; the only
                                 difference is that in the map that
                                 <code class="function">apply-string-subst-map</code> expects, <code class="sgmltag-attribute">oldstring</code> and <code class="sgmltag-attribute">newstring</code> attributes are used instead of
                                 <code class="sgmltag-attribute">character</code> and <code class="sgmltag-attribute">string</code> attributes.
                              </p>
                           </td>
                        </tr>
                     </table>
                  </div><pre class="programlisting"><a name="apply-string-subst-map.frag"></a><pre class="programlisting">
    &lt;xsl:template name="apply-string-subst-map"&gt;
      &lt;xsl:param name="content"&gt;&lt;/xsl:param&gt;
      &lt;xsl:param name="map.contents"&gt;&lt;/xsl:param&gt;
      &lt;xsl:variable name="replaced_text"&gt;
        &lt;xsl:call-template name="string.subst"&gt;
          &lt;xsl:with-param name="string" select="$content"&gt;&lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="target" select="$map.contents[1]/@oldstring"&gt;&lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="replacement" select="$map.contents[1]/@newstring"&gt;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:variable&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="$map.contents[2]"&gt;
          &lt;xsl:call-template name="apply-string-subst-map"&gt;
            &lt;xsl:with-param name="content" select="$replaced_text"&gt;&lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="map.contents" select="$map.contents[position() &gt; 1]"&gt;&lt;/xsl:with-param&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="$replaced_text"&gt;&lt;/xsl:value-of&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:template&gt;

  </pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="apply-character-map"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>apply-character-map &#8212; Apply an XSLT character map</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e483"></a><h2>Description</h2>
                  <p>This function applies an <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xslt20/#character-maps" target="_top">XSLT character
                        map</a>; that is, it cause certain individual characters to be
                     substituted with strings of one or more characters. It is useful
                     mainly for replacing multiple "special" chararacters or symbols in
                     the same target content. It reads in two things:
                     <em class="parameter"><code>content</code></em>, the content on which to perform the
                     substitution, and <em class="parameter"><code>map.contents</code></em>, a
                     node set of elements (the names of the elements don't matter), with
                     each element having the following attributes:
                     
                  </p>
                  <div class="itemizedlist">
                     <ul type="disc">
                        <li><code class="sgmltag-attribute">character</code>, a character to
                           be replaced
                        </li>
                        <li><code class="sgmltag-attribute">string</code>, a string with
                           which to replace <code class="sgmltag-attribute">character</code></li>
                     </ul>
                  </div>
                  <p>
                     This function uses <em class="parameter"><code>map.contents</code></em> to
                     do substitution on <em class="parameter"><code>content</code></em>, and then returns
                     the modified contents.
                  </p>
                  <div class="note">
                     <table border="0" summary="Note">
                        <tr>
                           <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
                           <th align="left"></th>
                        </tr>
                        <tr>
                           <td align="left" valign="top">
                              <p>This function is a very slightly modified version of Jeni
                                 Tennison's <code class="function">replace_strings</code> function in the
                                 <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.dpawson.co.uk/xsl/sect2/StringReplace.html#d9351e13" target="_top">multiple string replacements</a> section of Dave Pawson's
                                 <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.dpawson.co.uk/xsl/index.html" target="_top">XSLT
                                    FAQ</a>.
                              </p>
                              <p>The <code class="function">apply-string-subst-map</code> function is
                                 essentially the same function as the
                                 <code class="function">apply-character-map</code> function; the only
                                 difference is that in the map that
                                 <code class="function">apply-string-subst-map</code> expects, <code class="sgmltag-attribute">oldstring</code> and <code class="sgmltag-attribute">newstring</code> attributes are used instead of
                                 <code class="sgmltag-attribute">character</code> and <code class="sgmltag-attribute">string</code> attributes.
                              </p>
                           </td>
                        </tr>
                     </table>
                  </div><pre class="programlisting"><a name="apply-character-map.frag"></a><pre class="programlisting">
    &lt;xsl:template name="apply-character-map"&gt;
      &lt;xsl:param name="content"&gt;&lt;/xsl:param&gt;
      &lt;xsl:param name="map.contents"&gt;&lt;/xsl:param&gt;
      &lt;xsl:variable name="replaced_text"&gt;
        &lt;xsl:call-template name="string.subst"&gt;
          &lt;xsl:with-param name="string" select="$content"&gt;&lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="target" select="$map.contents[1]/@character"&gt;&lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="replacement" select="$map.contents[1]/@string"&gt;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:variable&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="$map.contents[2]"&gt;
          &lt;xsl:call-template name="apply-character-map"&gt;
            &lt;xsl:with-param name="content" select="$replaced_text"&gt;&lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="map.contents" select="$map.contents[position() &gt; 1]"&gt;&lt;/xsl:with-param&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="$replaced_text"&gt;&lt;/xsl:value-of&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:template&gt;

  </pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="read-character-map"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>read-character-map &#8212; Read in all or part of an XSLT character map</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e561"></a><h2>Description</h2>
                  <p>The XSLT 2.0 specification describes <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xslt20/#character-maps" target="_top">character
                        maps</a> and explains how they may be used to allow a specific
                     character appearing in a text or attribute node in a final results
                     tree to be substituted by a specified string of characters during
                     serialization. The <code class="function">read-character-map</code> function
                     provides a means for reading and using character maps with XSLT
                     1.0-based tools.
                  </p>
                  <p>It reads the character-map contents from
                     <em class="parameter"><code>uri</code></em> (in full or in part, depending on the value
                     of the <em class="parameter"><code>use.subset</code></em> parameter), then passes those
                     contents to the <code class="function">apply-character-map</code> function,
                     along with <em class="parameter"><code>content</code></em>, the data on which to
                     perform the character substition.
                  </p>
                  <p>Using the character map "in part" means that it uses only those
                     <code class="sgmltag-element">output-character</code> elements that match the XPATH expression
                     given in the value of the <em class="parameter"><code>subset.profile</code></em>
                     parameter. The current implementation of that capability here relies
                     on the <code class="function">evaluate</code> extension XSLT function.
                  </p><pre class="programlisting"><a name="read-character-map.frag"></a><pre class="programlisting">
  &lt;xsl:template name="read-character-map"&gt;
    &lt;xsl:param name="use.subset"&gt;&lt;/xsl:param&gt;
    &lt;xsl:param name="subset.profile"&gt;&lt;/xsl:param&gt;
    &lt;xsl:param name="uri"&gt;&lt;/xsl:param&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="$use.subset != 0"&gt;
        &lt;!-- use a subset of the character map instead of the full map --&gt;
        &lt;xsl:choose&gt;
          &lt;!-- xsltproc and Xalan both support dyn:evaluate() --&gt;
          &lt;xsl:when test="function-available('dyn:evaluate')"&gt;
            &lt;xsl:copy-of select="document($uri)//*[local-name()='output-character']                                  [dyn:evaluate($subset.profile)]"&gt;&lt;/xsl:copy-of&gt;
          &lt;/xsl:when&gt;
          &lt;!-- Saxon has its own evaluate() &amp; doesn't support dyn:evaluate() --&gt;
          &lt;xsl:when test="function-available('saxon:evaluate')"&gt;
            &lt;xsl:copy-of select="document($uri)//*[local-name()='output-character']                                  [saxon:evaluate($subset.profile)]"&gt;&lt;/xsl:copy-of&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:message terminate="yes"&gt;
Error: To process character-map subsets, you must use an XSLT engine
that supports the evaluate() XSLT extension function. Your XSLT engine
does not support it.
&lt;/xsl:message&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;!-- value of $use.subset is non-zero, so use the full map --&gt;
        &lt;xsl:copy-of select="document($uri)//*[local-name()='output-character']"&gt;&lt;/xsl:copy-of&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
</pre></pre></div>
            </div>
         </div>
         <div class="reference" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h1 class="title"><a name="relativeuri"></a>Relative URI Functions
                     </h1>
                  </div>
               </div>
               <hr>
            </div>
            <div class="partintro" lang="en">
               <div>
                  <div>
                     <div>
                        <h1 class="title"><a name="partintro"></a>Introduction
                        </h1>
                     </div>
                  </div>
               </div>
               <p>These functions manipulate relative URI references.</p>
               <p>The following assumptions must hold true:</p>
               <div class="orderedlist">
                  <ol type="1">
                     <li>
                        <p>All URIs are relative.</p>
                     </li>
                     <li>
                        <p>No URI contains the &#8220;<span class="quote"><code class="literal">../</code></span>&#8221; sequence
                           which would effectively move &#8220;<span class="quote">up</span>&#8221; the hierarchy.
                        </p>
                     </li>
                  </ol>
               </div>
               <p>If these assumptions do not hold, the results are unpredictable.</p>
               <div class="toc">
                  <p><b>Table of Contents</b></p>
                  <dl>
                     <dt><span class="refentrytitle"><a href="#count.uri.path.depth">count.uri.path.depth</a></span><span class="refpurpose"> &#8212; Count the number of path components in a relative URI</span></dt>
                     <dt><span class="refentrytitle"><a href="#trim.common.uri.paths">trim.common.uri.paths</a></span><span class="refpurpose"> &#8212; Trim common leading path components from a relative URI</span></dt>
                  </dl>
               </div>
            </div>
            <div class="refentry" lang="en"><a name="count.uri.path.depth"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>count.uri.path.depth &#8212; Count the number of path components in a relative URI</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e632"></a><h2>Description</h2>
                  <p>This function counts the number of path components in a relative URI.</p><pre class="programlisting"><a name="count.uri.path.depth.frag"></a><pre class="programlisting">
&lt;xsl:template name="count.uri.path.depth"&gt;
  &lt;xsl:param name="filename" select="''"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="count" select="0"&gt;&lt;/xsl:param&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($filename, '/')"&gt;
      &lt;xsl:call-template name="count.uri.path.depth"&gt;
        &lt;xsl:with-param name="filename" select="substring-after($filename, '/')"&gt;&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="count" select="$count + 1"&gt;&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="$count"&gt;&lt;/xsl:value-of&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
            <div class="refentry" lang="en">
               <div class="refentry.separator">
                  <hr>
               </div><a name="trim.common.uri.paths"></a><div class="titlepage"></div>
               <div class="refnamediv">
                  <h2>Name</h2>
                  <p>trim.common.uri.paths &#8212; Trim common leading path components from a relative URI</p>
               </div>
               <div class="refsect1" lang="en"><a name="d0e646"></a><h2>Description</h2>
                  <p>This function trims common leading path components from a relative URI.</p><pre class="programlisting"><a name="trim.common.uri.paths.frag"></a><pre class="programlisting">
&lt;xsl:template name="trim.common.uri.paths"&gt;
  &lt;xsl:param name="uriA" select="''"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="uriB" select="''"&gt;&lt;/xsl:param&gt;
  &lt;xsl:param name="return" select="'A'"&gt;&lt;/xsl:param&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($uriA, '/') and contains($uriB, '/')                     and substring-before($uriA, '/') = substring-before($uriB, '/')"&gt;
      &lt;xsl:call-template name="trim.common.uri.paths"&gt;
        &lt;xsl:with-param name="uriA" select="substring-after($uriA, '/')"&gt;&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="uriB" select="substring-after($uriB, '/')"&gt;&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="return" select="$return"&gt;&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="$return = 'A'"&gt;
          &lt;xsl:value-of select="$uriA"&gt;&lt;/xsl:value-of&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="$uriB"&gt;&lt;/xsl:value-of&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre></pre></div>
            </div>
         </div>
         <div class="appendix" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="stylesheet"></a>Appendix&nbsp;A.&nbsp;The Stylesheet
                     </h2>
                  </div>
               </div>
            </div>
            <p>The <code class="filename">lib.xsl</code> stylesheet is just a wrapper
               around these functions.
            </p><a name="top"></a><pre class="programlisting">

&lt;!-- ********************************************************************
     $Id: lib.xweb 6369 2006-10-19 08:40:35Z xmldoc $
     ********************************************************************

     This file is part of the XSL DocBook Stylesheet distribution.
     See ../README or http://nwalsh.com/docbook/xsl/ for copyright
     and other information.

     This module implements DTD-independent functions

     ******************************************************************** --&gt;

&lt;xsl:stylesheet exclude-result-prefixes="src" version="1.0"&gt;

&lt;src:fragref linkend="dot.count.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="copy-string.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="string.subst.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="xpointer.idref.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="length-magnitude.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="length-units.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="length-spec.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="length-in-points.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="pi-attribute.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="lookup.key.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="xpath.location.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="comment-escape-string.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="comment-escape-string.recursive.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="prepend-pad.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="str.tokenize.keep.delimiters.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="apply-string-subst-map.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="apply-character-map.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="read-character-map.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="count.uri.path.depth.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="trim.common.uri.paths.frag"&gt;&lt;/src:fragref&gt;
&lt;src:fragref linkend="trim.text.frag"&gt;&lt;/src:fragref&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
      </div>
   </body>
</html>
